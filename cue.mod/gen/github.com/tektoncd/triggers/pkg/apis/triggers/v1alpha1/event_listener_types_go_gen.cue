// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1

package v1alpha1

import (
	"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"knative.dev/pkg/apis"
	duckv1alpha1 "knative.dev/pkg/apis/duck/v1alpha1"
	duckv1beta1 "knative.dev/pkg/apis/duck/v1beta1"
)

// EventListener exposes a service to accept HTTP event payloads.
//
// +k8s:openapi-gen=true
#EventListener: {
	metav1.#TypeMeta

	// +optional
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// Spec holds the desired state of the EventListener from the client
	// +optional
	spec: #EventListenerSpec @go(Spec)

	// +optional
	status?: #EventListenerStatus @go(Status)
}

// EventListenerSpec defines the desired state of the EventListener, represented
// by a list of Triggers.
#EventListenerSpec: {
	serviceAccountName: string @go(ServiceAccountName)
	triggers: [...#EventListenerTrigger] @go(Triggers,[]EventListenerTrigger)
	serviceType?: corev1.#ServiceType @go(ServiceType)
	podTemplate?: #PodTemplate        @go(PodTemplate)
}

#PodTemplate: {
	tolerations?: [...corev1.#Toleration] @go(Tolerations,[]corev1.Toleration)
}

// EventListenerTrigger represents a connection between TriggerBinding, Params,
// and TriggerTemplate; TriggerBinding provides extracted values for
// TriggerTemplate to then create resources from.
#EventListenerTrigger: {
	bindings: [...null | #EventListenerBinding] @go(Bindings,[]*EventListenerBinding)
	template: #EventListenerTemplate @go(Template)

	// +optional
	name?: string @go(Name)
	ref?:  string @go(Ref)
	interceptors?: [...null | #EventInterceptor] @go(Interceptors,[]*EventInterceptor)

	// ServiceAccount optionally associates credentials with each trigger;
	// more granular authorization for
	// who is allowed to utilize the associated pipeline
	// vs. defaulting to whatever permissions are associated
	// with the entire EventListener and associated sink facilitates
	// multi-tenant model based scenarios
	// TODO do we want to restrict this to the event listener namespace and just ask for the service account name here?
	// +optional
	serviceAccount?: null | corev1.#ObjectReference @go(ServiceAccount,*corev1.ObjectReference)
}

// EventInterceptor provides a hook to intercept and pre-process events
#EventInterceptor: {
	webhook?:   null | #WebhookInterceptor   @go(Webhook,*WebhookInterceptor)
	github?:    null | #GitHubInterceptor    @go(GitHub,*GitHubInterceptor)
	gitlab?:    null | #GitLabInterceptor    @go(GitLab,*GitLabInterceptor)
	cel?:       null | #CELInterceptor       @go(CEL,*CELInterceptor)
	bitbucket?: null | #BitbucketInterceptor @go(Bitbucket,*BitbucketInterceptor)
}

// WebhookInterceptor provides a webhook to intercept and pre-process events
#WebhookInterceptor: {
	// ObjectRef is a reference to an object that will resolve to a cluster DNS
	// name to use as the EventInterceptor. Either objectRef or url can be specified
	// +optional
	objectRef?: null | corev1.#ObjectReference @go(ObjectRef,*corev1.ObjectReference)

	// Header is a group of key-value pairs that can be appended to the
	// interceptor request headers. This allows the interceptor to make
	// decisions specific to an EventListenerTrigger.
	header?: [...v1beta1.#Param] @go(Header,[]v1beta1.Param)
}

// BitbucketInterceptor provides a webhook to intercept and pre-process events
#BitbucketInterceptor: {
	secretRef?: null | #SecretRef @go(SecretRef,*SecretRef)
	eventTypes?: [...string] @go(EventTypes,[]string)
}

// GitHubInterceptor provides a webhook to intercept and pre-process events
#GitHubInterceptor: {
	secretRef?: null | #SecretRef @go(SecretRef,*SecretRef)
	eventTypes?: [...string] @go(EventTypes,[]string)
}

// GitLabInterceptor provides a webhook to intercept and pre-process events
#GitLabInterceptor: {
	secretRef?: null | #SecretRef @go(SecretRef,*SecretRef)
	eventTypes?: [...string] @go(EventTypes,[]string)
}

// CELInterceptor provides a webhook to intercept and pre-process events
#CELInterceptor: {
	filter?: string @go(Filter)
	overlays?: [...#CELOverlay] @go(Overlays,[]CELOverlay)
}

// CELOverlay provides a way to modify the request body using CEL expressions
#CELOverlay: {
	key?:        string @go(Key)
	expression?: string @go(Expression)
}

// SecretRef contains the information required to reference a single secret string
// This is needed because the other secretRef types are not cross-namespace and do not
// actually contain the "SecretName" field, which allows us to access a single secret value.
#SecretRef: {
	secretKey?:  string @go(SecretKey)
	secretName?: string @go(SecretName)
	namespace?:  string @go(Namespace)
}

// EventListenerBinding refers to a particular TriggerBinding or ClusterTriggerBindingresource.
#EventListenerBinding: {
	name?:       string                     @go(Name)
	kind?:       #TriggerBindingKind        @go(Kind)
	ref?:        string                     @go(Ref)
	spec?:       null | #TriggerBindingSpec @go(Spec,*TriggerBindingSpec)
	apiversion?: string                     @go(APIVersion)
}

// EventListenerTemplate refers to a particular TriggerTemplate resource.
#EventListenerTemplate: {
	name:        string @go(Name)
	apiversion?: string @go(APIVersion)
}

// EventListenerList contains a list of TriggerBinding
//
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
#EventListenerList: {
	metav1.#TypeMeta

	// +optional
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#EventListener] @go(Items,[]EventListener)
}

// EventListenerStatus holds the status of the EventListener
// +k8s:deepcopy-gen=true
#EventListenerStatus: {
	duckv1beta1.#Status

	duckv1alpha1.#AddressStatus

	// Configuration stores configuration for the EventListener service
	configuration: #EventListenerConfig @go(Configuration)
}

// EventListenerConfig stores configuration for resources generated by the
// EventListener
#EventListenerConfig: {
	// GeneratedResourceName is the name given to all resources reconciled by
	// the EventListener
	generatedName: string @go(GeneratedResourceName)
}

// ServiceExists is the ConditionType set on the EventListener, which
// specifies Service existence.
#ServiceExists: apis.#ConditionType & "Service"

// DeploymentExists is the ConditionType set on the EventListener, which
// specifies Deployment existence.
#DeploymentExists: apis.#ConditionType & "Deployment"

// Check that EventListener may be validated and defaulted.
// TriggerBindingKind defines the type of TriggerBinding used by the EventListener.
#TriggerBindingKind: string // #enumTriggerBindingKind

#enumTriggerBindingKind:
	#NamespacedTriggerBindingKind |
	#ClusterTriggerBindingKind

// NamespacedTriggerBindingKind indicates that triggerbinding type has a namespace scope.
#NamespacedTriggerBindingKind: #TriggerBindingKind & "TriggerBinding"

// ClusterTriggerBindingKind indicates that triggerbinding type has a cluster scope.
#ClusterTriggerBindingKind: #TriggerBindingKind & "ClusterTriggerBinding"
